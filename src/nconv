#!/bin/sh

#-------------------------------------------------------------------------------
# Copyright 2020 Dominik Salvet
# https://github.com/dominiksalvet/nconv
#-------------------------------------------------------------------------------
# DESCRIPTION:
#   This is a simple binary-decimal converter intended for a terminal use.
# PARAMETERS:
#   All given arguments are processed as nconv help describes.
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# GENERAL INITIALIZATION
#-------------------------------------------------------------------------------

# PARAMETERS:
#   $@ - nconv arguments
main() {
    init_constants &&
    init_strings &&
    init_opts &&
    process_args "$@"
}

init_constants() {
    readonly VERSION=0.2.0 # the current nconv version
}

init_strings() {
    readonly HELP_MESSAGE='USAGE:
  nconv [OPTION...] NUMBER...
  nconv help | about

OPTION:
  -b/-d/-h  binary/decimal/hexadecimal input
  -s/-u     signed/unsigned input
  -B/-D/-H  binary/decimal/hexadecimal output
  -W WIDTH  number of output digits'

    readonly ABOUT_MESSAGE="nconv $VERSION
Binary, decimal, and hexadecimal converter.

Copyright 2020 Dominik Salvet
https://github.com/dominiksalvet/nconv"
}

init_opts() {
    # global variables
    input_radix= # bin, dec, hex
    input_sign= # signed, unsigned
    output_radix= # bin, dec, hex
    output_width= # a positive number
}

#-------------------------------------------------------------------------------
# ARGUMENT PROCESSING
#-------------------------------------------------------------------------------

# PARAMETERS:
#   $@ - nconv arguments
process_args() (
    case "$1" in
        help) echo "$HELP_MESSAGE" ;;
        about) echo "$ABOUT_MESSAGE" ;;
        *)  process_opts "$@" &&
            shift "$((OPTIND - 1))" && # shift to numbers
            process_nums "$@" ;;
    esac
)

# PARAMETERS:
#   $@ - nconv options
process_opts() {
    while getopts :bdhsuBDHW:0123456789 _opt; do
        case "$_opt" in
            b) input_radix=bin ;;
            d) input_radix=dec ;;
            h) input_radix=hex ;;
            s) input_sign=signed ;;
            u) input_sign=unsigned ;;

            B) output_radix=bin ;;
            D) output_radix=dec ;;
            H) output_radix=hex ;;

            W)  if ! [ "$OPTARG" -gt 0 ] 2>/dev/null; then
                    echo "invalid output width $OPTARG" >&2; return 1
                fi
                output_width="$OPTARG" ;;

            [0-9]) OPTIND="$((OPTIND - 1))" && break ;; # negative dec number
            :) echo "option -$OPTARG requires an argument" >&2; return 1 ;;
            ?) echo "invalid option -$OPTARG" >&2; return 1 ;;
        esac || return
    done
}

# PARAMETERS:
#   $@ - numbers
process_nums() (
    if [ "$#" -eq 0 ]; then
        echo 'no number provided' >&2; return 1
    fi

    # missing conversion parameters are deduced from the first number
    init_conversion "$1" &&
    for num in "$@"; do
        result="$(convert_num "$num")" &&
        # print result as a single line
        echo "$result" | sed ':a; N; s/\\\n//; ba' || return
    done
)

#-------------------------------------------------------------------------------
# CONVERSION INITIALIZATION
#-------------------------------------------------------------------------------

# PARAMETERS:
#   $1 - main number
init_conversion() {
    init_input_radix "$1" &&
    init_input_sign "$1" &&
    init_output_radix
}

# PARAMETERS:
#   $1 - main number
init_input_radix() {
    if ! [ "$input_radix" ]; then
        if is_bin_num "$1"; then
            input_radix=bin;
        elif is_dec_num "$1"; then
            input_radix=dec;
        elif is_hex_num "$1"; then
            input_radix=hex;
        else
            echo "invalid main number $1" >&2; return 1
        fi
    fi
}

# PARAMETERS:
#   $1 - main number
init_input_sign() {
    if ! [ "$input_sign" ]; then
        case "$1" in
            -*) input_sign=signed ;;
            *) input_sign=unsigned ;;
        esac
    fi
}

init_output_radix() {
    if ! [ "$output_radix" ]; then
        case "$input_radix" in
            bin | hex) output_radix=dec ;;
            dec) output_radix=bin ;;
            *) echo "invalid input radix $input_radix" >&2; return 1
        esac
    fi
}

# PARAMETERS:
#   $1 - number
is_bin_num() {
    echo "$1" | grep -qE '^[01]+$'
}

# PARAMETERS:
#   $1 - number
is_dec_num() {
    echo "$1" | grep -qE '^-?[0123456789]+$'
}

# PARAMETERS:
#   $1 - number
is_hex_num() {
    echo "$1" | grep -qE '^[0123456789ABCDEF]+$'
}

#-------------------------------------------------------------------------------
# CONVERSIONS
#-------------------------------------------------------------------------------

# PARAMETERS:
#   $1 - number
convert_num() {
    case "$input_radix$output_radix" in
        binbin) init_bin_input "$1" && bin_to_bin "$1" ;;
        bindec) init_bin_input "$1" && bin_to_dec "$1" ;;
        binhex) init_bin_input "$1" && bin_to_hex "$1" ;;

        decbin) init_dec_input "$1" && dec_to_bin "$1" ;;
        decdec) init_dec_input "$1" && dec_to_dec "$1" ;;
        dechex) init_dec_input "$1" && dec_to_hex "$1" ;;

        hexbin) init_hex_input "$1" && hex_to_bin "$1" ;;
        hexdec) init_hex_input "$1" && hex_to_dec "$1" ;;
        hexhex) init_hex_input "$1" && hex_to_hex "$1" ;;

        *) echo "invalid conversion $input_radix -> $output_radix" >&2; return 1
    esac
}

# PARAMETERS:
#   $1 - number
init_bin_input() {
    if ! is_bin_num "$1"; then
        echo "invalid binary number $1" >&2; return 1
    fi
}

# PARAMETERS:
#   $1 - number
init_dec_input() {
    if ! is_dec_num "$1"; then
        echo "invalid decimal number $1" >&2; return 1
    elif [ "$input_sign" = unsigned ]; then
        case "$1" in -*)
            echo "invalid unsigned decimal number $1" >&2; return 1 ;;
        esac
    fi
}

# PARAMETERS:
#   $1 - number
init_hex_input() {
    if ! is_hex_num "$1"; then
        echo "invalid hexadecimal number $1" >&2; return 1
    fi
}

#-------------------------------------------------------------------------------
# BINARY CONVERSION
#-------------------------------------------------------------------------------

# PARAMETERS:
#   $1 - binary number
bin_to_bin() (
    num="$(canonical_bin "$1")" &&
    if [ "$output_width" ]; then
        num="$(extend_cbin "$num")"
    fi &&
    echo "$num"
)

# PARAMETERS:
#   $1 - binary number
bin_to_dec() (
    bin_num="$(canonical_bin "$1")" &&
    dec_num="$(echo "ibase=2; $bin_num" | bc)" &&
    if [ "$input_sign" = signed ]; then
        case "$bin_num" in 1*) # negative binary numbers
            dec_num="$(echo "$dec_num - 2^${#1}" | bc)" ;;
        esac
    fi &&
    if [ "$output_width" ]; then
        dec_num="$(extend_cdec "$dec_num")"
    fi &&
    echo "$dec_num"
)

# PARAMETERS:
#   $1 - binary number
bin_to_hex() (
    bin_num="$(canonical_bin "$1")" &&
    hex_num="$(echo "obase=16; ibase=2; $bin_num" | bc)" &&
    if [ "$input_sign" = signed ]; then
        target_msb="$(echo "$bin_num" | cut -c 1)" &&
        hex_num="$(adjust_hex_sign "$hex_num" "$target_msb")"
    fi &&
    if [ "$output_width" ]; then
        hex_num="$(extend_chex "$hex_num")"
    fi &&
    echo "$hex_num"
)

# PARAMETERS:
#   $1 - binary number
canonical_bin() (
    case "$1" in
        1*) echo "$1" ;;
        *)  num="$(echo "$1" | sed 's/^0*//')" && # remove leading zeros
            if ! [ "$num" ] || [ "$input_sign" = signed ]; then
                num="0$num"
            fi &&
            echo "$num" ;;
    esac
)

# PARAMETERS:
#   $1 - canonical binary number
extend_cbin() (
    extend_by="$((output_width - ${#1}))" &&
    if [ "$extend_by" -ge 0 ]; then
        if [ "$input_sign" = signed ]; then
            extend_bit="$(echo "$1" | cut -c 1)"
        else
            extend_bit=0
        fi &&
        extend_bits="$(repeat_char "$extend_bit" "$extend_by")" &&
        echo "$extend_bits$1"
    else
        echo "could not fit $1 into $output_width digits" >&2; return 1
    fi
)

# PARAMETERS:
#   $1 - character
#   $2 - count
repeat_char() (
    spaces="$(printf "%$2s")" &&
    echo "$spaces" | tr ' ' "$1"
)

#-------------------------------------------------------------------------------
# DECIMAL CONVERSION
#-------------------------------------------------------------------------------

# PARAMETERS:
#   $1 - decimal number
dec_to_bin() (
    dec_num="$(canonical_dec "$1")" &&
    case "$dec_num" in
        -*) dec_num="$((-dec_num - 1))" &&
            bin_num="$(echo "obase=2; $dec_num" | bc)" &&
            bin_num="1$(echo "$bin_num" | tr 01 10)" ;; # invert bits
        *)  bin_num="$(echo "obase=2; $dec_num" | bc)" &&
            if [ "$input_sign" = signed ]; then
                bin_num="0$bin_num"
            fi ;;
    esac &&
    if [ "$output_width" ]; then
        bin_num="$(extend_cbin "$bin_num")"
    fi &&
    echo "$bin_num"
)

# PARAMETERS:
#   $1 - decimal number
dec_to_dec() (
    num="$(canonical_dec "$1")" &&
    if [ "$output_width" ]; then
        num="$(extend_cdec "$num")"
    fi &&
    echo "$num"
)

# PARAMETERS:
#   $1 - decimal number
dec_to_hex() (
    dec_num="$(canonical_dec "$1")" &&
    hex_num="$(echo "obase=16; ${dec_num#-}" | bc)" &&
    if [ "$input_sign" = signed ]; then
        case "$1" in
            -*) target_msb=1 ;;
            *) target_msb=0 ;;
        esac
        hex_num="$(adjust_hex_sign "$hex_num" "$target_msb")"
    fi &&
    if [ "$output_width" ]; then
        hex_num="$(extend_chex "$hex_num")"
    fi &&
    echo "$hex_num"
)

# PARAMETERS:
#   $1 - decimal number
canonical_dec() (
    case "$1" in
        -*) sign=- ;;
        *) sign= ;;
    esac

    num="$(echo "$1" | sed 's/^-\?0*//')" &&
    if ! [ "$num" ]; then
        num=0
    fi &&
    if [ "$num" != 0 ]; then
        num="$sign$num"
    fi &&
    echo "$num"
)

# PARAMETERS:
#   $1 - canonical decimal number
extend_cdec() (
    abs_num="${1#-}"
    extend_by="$((output_width - ${#abs_num}))" &&
    if [ "$extend_by" -ge 0 ]; then
        case "$1" in
            -*) sign=- ;;
            *) sign= ;;
        esac
        extend_zeros="$(repeat_char 0 "$extend_by")" &&
        echo "$sign$extend_zeros$abs_num"
    else
        echo "could not fit $1 into $output_width digits" >&2; return 1
    fi
)

#-------------------------------------------------------------------------------
# HEXADECIMAL CONVERSION
#-------------------------------------------------------------------------------

# PARAMETERS:
#   $1 - hexadecimal number
hex_to_bin() {
    echo "hex_to_bin $1"
}

# PARAMETERS:
#   $1 - hexadecimal number
hex_to_dec() {
    echo "hex_to_dec $1"
}

# PARAMETERS:
#   $1 - hexadecimal number
hex_to_hex() {
    echo "hex_to_hex $1"
}

# PARAMETERS:
#   $1 - canonical hexadecimal number
#   $2 - target most significant bit
adjust_hex_sign() (
    left_digit="$(echo "$1" | cut -c 1)" &&
    case "$2" in
        0)  case "$left_digit" in [8-9] | [A-F]) # negative -> positive
                left_digit="0$left_digit" ;;
            esac ;;
        1)  case "$left_digit" in # positive -> negative
                1 | 3 | 7) left_digit=F ;;
                2 | 6) left_digit=E ;;
                4) left_digit=C ;;
                5) left_digit=D ;;
            esac ;;
    esac &&
    echo "$left_digit${1#?}"
)

# PARAMETERS:
#   $1 - canonical hexadecimal number
extend_chex() (
    extend_by="$((output_width - ${#1}))" &&
    if [ "$extend_by" -ge 0 ]; then
        extend_digit=0
        if [ "$input_sign" = signed ]; then
            case "$1" in [8-9]* | [A-F]*)
                extend_digit=F ;;
            esac
        fi &&
        extend_digits="$(repeat_char "$extend_digit" "$extend_by")" &&
        echo "$extend_digits$1"
    else
        echo "could not fit $1 into $output_width digits" >&2; return 1
    fi
)

#-------------------------------------------------------------------------------
# CALL MAIN
#-------------------------------------------------------------------------------

main "$@"
